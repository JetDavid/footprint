# 云原生

## 定义和愿景

一条最佳路径：

- 低心智负担
- 敏捷的
- 可扩展，可复制的方式，最大化利用“云”的能力，发挥“云”的价值

愿景： 软件从诞生起就生在云上，长在云上的全新的软件开发，发布和运维模式。

## 技术范畴

1. 云应用定义与开发流程。这包括应用定义与镜像制作、配置 CI/CD、消息和 Streaming 以及数据库等。
2. 云应用的编排与管理流程。这也是 Kubernetes 比较关注的一部分，包括了应用编排与调度、服务发现治理、远程调用、API 网关以及 Service Mesh。
3. 监控与可观测性。这部分所强调的是云上应用如何进行监控、日志收集、Tracing 以及在云上如何实现破坏性测试，也就是混沌工程的概念。
4. 云原生的底层技术，比如容器运行时、云原生存储技术、云原生网络技术等。
5. 云原生工具集，在前面的这些核心技术点之上，还有很多配套的生态或者周边的工具需要使用，比如流程自动化与配置管理、容器镜像仓库、云原生安全技术以及云端密码管理等。
6. Serverless。Serverless 是一种 PaaS 的特殊形态，它定义了一种更为“极端抽象”的应用编写方式，包含了 FaaS 和 BaaS 这样的概念。而无论是 FaaS 还是 BaaS，其最为典型的特点就是按实际使用计费（Pay as you go），因此 Serverless 计费也是重要的知识和概念。

## 理论支撑

不可变基础设施。这一点目前是通过容器镜像来实现的，其含义就是应用的基础设施应该是不可变的，是一个自包含、自描述可以完全在不同环境中迁移的东西；

- 直接更替容器镜像，而容器镜像是自包含的，具有从测试完成-生产的一致性。可以随时替换，但传统意义上的应用基础设施需要细心呵护。
- 最大意义在于：用户只关心应用，应用可以随意扩展，运行，测试，迁移。因为围绕应用的所有管控，运维，发布，基础设施都是一致的。

云应用编排理论。当前的实现方式就是 Google 所提出来的“容器设计模式”，这也是本系列课程中的 Kubernetes 部分所需主要讲解的内容。

## 关键技术点

1. 如何构建自包含、可定制的应用镜像；
2. 能不能实现应用快速部署与隔离能力；
3. 应用基础设施创建和销毁的自动化管理；
4. 可复制的管控系统和支撑组件。

## 容器基本概念

1. 容器解决了视图隔离，资源隔离，文件隔离的问题。
2. 容器镜像解决了文件隔离，而分层的实现，提高了分发，下载速度。节省了存储空间
3. initial进程管理容器生命周期，而它的销毁意味着容器运行空间的销毁。所以持久化数据要放到数据卷。
4. moby是较为流行的容器管理工具。moby是docker项目的姊妹，更多面向开发者和贡献者，用来保持对docker容器的热情，和持续的新想法。为docker社区提供技术需求。
5. 和VM相比，更轻量，省资源，但隔离性差，未来趋势是安全容器

## Kubernetes

### 核心功能

1. 编排（orchestration）的目的：解决应用所有的后顾之忧。具体完成部署，弹性，管理。
2. Borg面向应用编排解决的问题： 1）屏蔽基础设施复杂度和容错处理；2）提高应用可靠性和可用性；3）更高效的大规模调度。

- 服务的发现与负载的均衡；
- 容器的自动装箱：我们也会把它叫做 scheduling，就是“调度”，把一个容器放到一个集群的某一个机器上，Kubernetes 会帮助我们去做存储的编排，让存储的声明周期与容器的生命周期能有一个连接；
- 自动容器恢复：Kubernetes 会帮助我们去做自动化的容器的恢复。在一个集群中，经常会出现宿主机的问题或者说是 OS 的问题，导致容器本身的不可用，Kubernetes 会自动地对这些不可用的容器进行恢复；
- 自动发布和回滚：Kubernetes 会帮助我们去做应用的自动发布与应用的回滚；
- 应用相关的配置密文的管理；
- 批量执行：对于 job 类型任务，Kubernetes 可以去做批量的执行；
- 水平伸缩：为了让这个集群、这个应用（可以监视当负载太高，而水平扩展）更富有弹性，Kubernetes 也支持水平的伸缩。

### 核心概念

- Pod: k8s的最基本单位。多个容器组成。pod描述了应用的运行空间（cmd，环境变量）；pod内部容器间localhost通信，pod间是相互隔离的。
- Volume: pod的数据持久化。可以支持多种后端存储。也可以多点挂载
- Deployment: Pod上面一层的抽象，发布应用的管理单位。可以完成主备，升级和回滚应用
- Service: 提供一个或多个Pod实例稳定的访问地址。支持ClusterIP, nodePort, LoadBalance方式。
- Namespace: 集群内部逻辑隔离机制（鉴权，资源配额），每个资源属于一个NS，不同NS之间资源命名可以重复，同一个NS内部资源命名唯一

#### POD的本质和概念

POD本质上就是一个进程，只是它被视图隔离，资源隔离。

> - 管理POD=管理应用：相较于传统架构而言，管理应用 == 管理操作系统 + 管理基础设施 + 应用。而到了容器时代，管理容器 == 管理应用，不用关心操作系统和基础设施。而承载应用的就是POD，他就是发布应用的软件包和程序。对应的操作系统就是kubernetes.
> - POD=进程组：容器是单进程设计模式，在传统模式下，一个进程可能会fork很多子进程，这就意味着当子进程退出时需要回收。也就要求父进程具备进程管理能力。而容器内进程，本身是PID=1的进程，按照容器的设计目标，需要管理应用，而多个子进程的出现会迫使应用（PID=1）需要管理进程，那么大多数场景会采用systemd，tini等等方式。这样就造成容器为应用而设计，变成容器为systemd而设计，很多围绕应用的生命周期管理和监控就变成鸡肋。但多子进程也是常见的情况，因此POD（多容器）的出现尤其重要
> - 原子调度单位： Task co-scheduling问题是调度中常见问题。2个相关实例（容器，进程）需要在一起运行。当调度时：
>   - Mesos采取资源囤积（resource hoarding）策略，相互依赖的实例都提交后，再调度。缺点：调度效率低，容易死锁，相互等待。
>   - Omega采取乐观调度。优先将其中一个实例调度，当发现剩余的资源不够是，精确回滚。缺点：实现复杂度大。
>   - Kubernetes采取POD模式，定义统一的数据模型，解决了很多问题。
> - 超亲密关系进程：依赖关系十分紧密的多个进程。比如：localhost, unix socket通信; 文件交换；RPC通信等等

容器的设计模式：sidecar

- sidecar主要围绕主业务进程做一些辅助工作。好处：1. 与主业务解耦，2者可以单独发布；2. 辅助sidecar container的镜像可以复用到多个业务中去。init container是一种sidecar模式。
- sidecar的主要应用有： 日志收集（fluentd）；代理容器（例如：主业务容器对外访问同一个服务，多个IP，此时多连接的建立，可以由proxy容器完成）；适配器容器（例如：当主业务容器的API需要升级，但是旧代码又得兼容，这部分兼容工作可以交给adapter处理。）

#### 应用编排和管理

kubernetes将应用所对应的资源对象描述为：spec, status, metadata（label, annotation, owner-reference）三部分。分别对应：期望的状态，当前状态，元信息。

